[
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "MessageQueue",
            "lineno": 12,
            "end_lineno": 25,
            "col_offset": 0,
            "end_col_offset": 38,
            "source_code": "class MessageQueue:\n    \"\"\"Handle message queuing and processing.\n\n    Args:\n        queue_name: str\n            Name of the message queue.\n        max_size: int\n            Maximum number of messages in queue.\n    \"\"\"\n\n    def __init__(self, queue_name: str, max_size: int, retry_attempts: int,\n        persistence: bool=True):\n        self.queue_name = queue_name\n        self.max_size = max_size\n        self.retry_attempts = retry_attempts\n        self.persistence = persistence\n",
            "docstring": "Handle message queuing and processing.\n\nArgs:\n    queue_name: str\n        Name of the message queue.\n    max_size: int\n        Maximum number of messages in queue.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 21,
                "end_lineno": 25,
                "col_offset": 4,
                "end_col_offset": 38,
                "source_code": "def __init__(self, queue_name: str, max_size: int, retry_attempts: int,\n    persistence: bool=True):\n    self.queue_name = queue_name\n    self.max_size = max_size\n    self.retry_attempts = retry_attempts\n    self.persistence = persistence\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is missing two constructor parameters: 'retry_attempts' and 'persistence'. The existing documented parameters have correct types and descriptions, but the docstring is incomplete. Added the missing parameters with appropriate descriptions and noted the default value for the persistence parameter.",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Handle message queuing and processing",
                "correct_class_arguments": [
                    {
                        "name": "queue_name",
                        "data_type": "str",
                        "description": "Name of the message queue"
                    },
                    {
                        "name": "max_size",
                        "data_type": "int",
                        "description": "Maximum number of messages in queue"
                    },
                    {
                        "name": "retry_attempts",
                        "data_type": "int",
                        "description": "Number of retry attempts for failed message processing"
                    },
                    {
                        "name": "persistence",
                        "data_type": "bool",
                        "description": "Whether to persist messages to storage. Defaults to True"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "ImageResizer",
            "lineno": 28,
            "end_lineno": 41,
            "col_offset": 0,
            "end_col_offset": 30,
            "source_code": "class ImageResizer:\n    \"\"\"Resize and optimize images for web usage.\n\n    Args:\n        input_path: int\n            Path to input image file.\n        quality: str\n            Image compression quality setting.\n        preserve_metadata: bool\n            Whether to keep EXIF data in output.\n    \"\"\"\n\n    def __init__(self, input_path: str, quality: int=85):\n        self.input_path = input_path\n        self.quality = quality\n",
            "docstring": "Resize and optimize images for web usage.\n\nArgs:\n    input_path: int\n        Path to input image file.\n    quality: str\n        Image compression quality setting.\n    preserve_metadata: bool\n        Whether to keep EXIF data in output.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 39,
                "end_lineno": 41,
                "col_offset": 4,
                "end_col_offset": 30,
                "source_code": "def __init__(self, input_path: str, quality: int=85):\n    self.input_path = input_path\n    self.quality = quality\n"
            }
        },
        "assessment": {
            "summary_of_findings": "Multiple issues found: 1) Parameter 'preserve_metadata' is documented but doesn't exist in constructor, 2) 'input_path' type is incorrectly documented as 'int' when it should be 'str', 3) 'quality' type is incorrectly documented as 'str' when it should be 'int', 4) Missing default value information for 'quality' parameter which defaults to 85",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": false,
            "corrected_class_docstring": {
                "correct_class_description": "Resize and optimize images for web usage",
                "correct_class_arguments": [
                    {
                        "name": "input_path",
                        "data_type": "str",
                        "description": "Path to input image file"
                    },
                    {
                        "name": "quality",
                        "data_type": "int",
                        "description": "Image compression quality setting. Defaults to 85"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "PasswordValidator",
            "lineno": 44,
            "end_lineno": 50,
            "col_offset": 0,
            "end_col_offset": 42,
            "source_code": "class PasswordValidator:\n\n    def __init__(self, min_length: int=8, require_uppercase: bool=True,\n        require_numbers: bool=True, special_chars: Optional[str]=None):\n        self.min_length = min_length\n        self.require_uppercase = require_uppercase\n        self.require_numbers = require_numbers\n        self.special_chars = special_chars\n",
            "docstring": null,
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 45,
                "end_lineno": 50,
                "col_offset": 4,
                "end_col_offset": 42,
                "source_code": "def __init__(self, min_length: int=8, require_uppercase: bool=True,\n    require_numbers: bool=True, special_chars: Optional[str]=None):\n    self.min_length = min_length\n    self.require_uppercase = require_uppercase\n    self.require_numbers = require_numbers\n    self.special_chars = special_chars\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The class has no docstring at all. Based on the constructor parameters and their types, this appears to be a password validator class. All validation flags are false because there is no existing documentation to evaluate. Created a complete docstring documenting all four constructor parameters with their correct types and default values.",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": false,
            "corrected_class_docstring": {
                "correct_class_description": "Validate password strength based on configurable requirements",
                "correct_class_arguments": [
                    {
                        "name": "min_length",
                        "data_type": "int",
                        "description": "Minimum required password length. Defaults to 8."
                    },
                    {
                        "name": "require_uppercase",
                        "data_type": "bool",
                        "description": "Whether to require at least one uppercase letter. Defaults to True."
                    },
                    {
                        "name": "require_numbers",
                        "data_type": "bool",
                        "description": "Whether to require at least one numeric digit. Defaults to True."
                    },
                    {
                        "name": "special_chars",
                        "data_type": "Optional[str]",
                        "description": "String of special characters to require in passwords. Defaults to None."
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "NotificationService",
            "lineno": 53,
            "end_lineno": 70,
            "col_offset": 0,
            "end_col_offset": 38,
            "source_code": "class NotificationService:\n    \"\"\"Send notifications via multiple channels.\n\n    Args:\n        email_enabled: bool\n            Whether email notifications are enabled.\n        sms_enabled: bool\n            Whether SMS notifications are enabled.\n        webhook_url: str\n            URL for webhook notifications.\n        rate_limit: int\n            Maximum notifications per minute.\n        templates: Dict[str, str]\n            Notification template mappings.\n    \"\"\"\n\n    def __init__(self, email_enabled: bool, sms_enabled: bool=False):\n        self.email_enabled = email_enabled\n        self.sms_enabled = sms_enabled\n",
            "docstring": "Send notifications via multiple channels.\n\nArgs:\n    email_enabled: bool\n        Whether email notifications are enabled.\n    sms_enabled: bool\n        Whether SMS notifications are enabled.\n    webhook_url: str\n        URL for webhook notifications.\n    rate_limit: int\n        Maximum notifications per minute.\n    templates: Dict[str, str]\n        Notification template mappings.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 68,
                "end_lineno": 70,
                "col_offset": 4,
                "end_col_offset": 38,
                "source_code": "def __init__(self, email_enabled: bool, sms_enabled: bool=False):\n    self.email_enabled = email_enabled\n    self.sms_enabled = sms_enabled\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring contains three extra parameters (webhook_url, rate_limit, templates) that don't exist in the constructor. The constructor only takes email_enabled (required) and sms_enabled (optional, defaults to False). The existing parameter descriptions are accurate, but the docstring needs to be corrected to remove the non-existent parameters and add default value information for sms_enabled.",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Send notifications via multiple channels",
                "correct_class_arguments": [
                    {
                        "name": "email_enabled",
                        "data_type": "bool",
                        "description": "Whether email notifications are enabled."
                    },
                    {
                        "name": "sms_enabled",
                        "data_type": "bool",
                        "description": "Whether SMS notifications are enabled. Defaults to False."
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "HttpClient",
            "lineno": 73,
            "end_lineno": 91,
            "col_offset": 0,
            "end_col_offset": 36,
            "source_code": "class HttpClient:\n    \"\"\"HTTP client for making REST API requests.\n\n    Args:\n        base_url: str\n            The URL.\n        timeout: int\n            The timeout.\n        retries: int\n            The retries.\n        user_agent: str\n            The user agent.\n    \"\"\"\n\n    def __init__(self, base_url: str, timeout: float=30.0, retries: int=3,\n        user_agent: str='HttpClient/1.0'):\n        self.base_url = base_url\n        self.timeout = timeout\n        self.retries = retries\n        self.user_agent = user_agent\n",
            "docstring": "HTTP client for making REST API requests.\n\nArgs:\n    base_url: str\n        The URL.\n    timeout: int\n        The timeout.\n    retries: int\n        The retries.\n    user_agent: str\n        The user agent.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 86,
                "end_lineno": 91,
                "col_offset": 4,
                "end_col_offset": 36,
                "source_code": "def __init__(self, base_url: str, timeout: float=30.0, retries: int=3,\n    user_agent: str='HttpClient/1.0'):\n    self.base_url = base_url\n    self.timeout = timeout\n    self.retries = retries\n    self.user_agent = user_agent\n"
            }
        },
        "assessment": {
            "summary_of_findings": "All parameter names are present, but the timeout parameter type is wrong (documented as int but should be float), and all descriptions are too vague ('The URL', 'The timeout', etc.) without mentioning default values or providing meaningful context",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": false,
            "corrected_class_docstring": {
                "correct_class_description": "Provide HTTP client for making REST API requests",
                "correct_class_arguments": [
                    {
                        "name": "base_url",
                        "data_type": "str",
                        "description": "Base URL for the REST API endpoint"
                    },
                    {
                        "name": "timeout",
                        "data_type": "float",
                        "description": "Request timeout in seconds. Defaults to 30.0"
                    },
                    {
                        "name": "retries",
                        "data_type": "int",
                        "description": "Maximum number of retry attempts for failed requests. Defaults to 3"
                    },
                    {
                        "name": "user_agent",
                        "data_type": "str",
                        "description": "User agent string for HTTP requests. Defaults to 'HttpClient/1.0'"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "BackupManager",
            "lineno": 94,
            "end_lineno": 110,
            "col_offset": 0,
            "end_col_offset": 46,
            "source_code": "class BackupManager:\n    \"\"\"Manage automated backups of files and databases.\n\n    Args:\n        backup_directory: str\n            Directory where backups will be stored.\n        retention_days: int\n            Number of days to keep backups.\n        compression_enabled: bool\n            Whether to compress backup files.\n    \"\"\"\n\n    def __init__(self, backup_directory: str, retention_days: int=30,\n        compression_enabled: bool=True, max_backup_size: int=1073741824):\n        self.backup_directory = backup_directory\n        self.retention_days = retention_days\n        self.compression_enabled = compression_enabled\n        self.max_backup_size = max_backup_size\n",
            "docstring": "Manage automated backups of files and databases.\n\nArgs:\n    backup_directory: str\n        Directory where backups will be stored.\n    retention_days: int\n        Number of days to keep backups.\n    compression_enabled: bool\n        Whether to compress backup files.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 105,
                "end_lineno": 110,
                "col_offset": 4,
                "end_col_offset": 46,
                "source_code": "def __init__(self, backup_directory: str, retention_days: int=30,\n    compression_enabled: bool=True, max_backup_size: int=1073741824):\n    self.backup_directory = backup_directory\n    self.retention_days = retention_days\n    self.compression_enabled = compression_enabled\n    self.max_backup_size = max_backup_size\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is missing the 'max_backup_size' parameter that exists in the constructor. Additionally, the descriptions for optional parameters don't mention their default values (retention_days=30, compression_enabled=True, max_backup_size=1073741824). All documented parameter types are correct.",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": false,
            "corrected_class_docstring": {
                "correct_class_description": "Manage automated backups of files and databases",
                "correct_class_arguments": [
                    {
                        "name": "backup_directory",
                        "data_type": "str",
                        "description": "Directory where backups will be stored"
                    },
                    {
                        "name": "retention_days",
                        "data_type": "int",
                        "description": "Number of days to keep backups. Defaults to 30"
                    },
                    {
                        "name": "compression_enabled",
                        "data_type": "bool",
                        "description": "Whether to compress backup files. Defaults to True"
                    },
                    {
                        "name": "max_backup_size",
                        "data_type": "int",
                        "description": "Maximum size in bytes for individual backup files. Defaults to 1073741824"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "VideoProcessor",
            "lineno": 112,
            "end_lineno": 133,
            "col_offset": 0,
            "end_col_offset": 32,
            "source_code": "class VideoProcessor:\n    \"\"\"Process video files with various transformations.\n\n    Args:\n        codec: List[str]\n            Video codec to use for encoding.\n        bitrate: int\n            Target bitrate in kbps. Defaults to 2000.\n        resolution: Tuple[int, int]\n            Output resolution as (width, height). Defaults to (1920, 1080).\n        audio_enabled: bool\n            Whether to include audio track. Defaults to True.\n        metadata: Optional[Dict[str, Any]]\n            Custom metadata to embed in output. Defaults to None.\n    \"\"\"\n\n    def __init__(self, codec: str, bitrate: int=2000, resolution: Tuple[int,\n        int]=(1920, 1080), audio_enabled: bool=True, metadata: Optional[\n        Dict[str, Any]]=None):\n        self.codec = codec\n        self.bitrate = bitrate\n        self.resolution = resolution\n        self.audio_enabled = audio_enabled\n        self.metadata = metadata\n",
            "docstring": "Process video files with various transformations.\n\nArgs:\n    codec: List[str]\n        Video codec to use for encoding.\n    bitrate: int\n        Target bitrate in kbps. Defaults to 2000.\n    resolution: Tuple[int, int]\n        Output resolution as (width, height). Defaults to (1920, 1080).\n    audio_enabled: bool\n        Whether to include audio track. Defaults to True.\n    metadata: Optional[Dict[str, Any]]\n        Custom metadata to embed in output. Defaults to None.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 127,
                "end_lineno": 133,
                "col_offset": 4,
                "end_col_offset": 32,
                "source_code": "def __init__(self, codec: str, bitrate: int=2000, resolution: Tuple[int,\n    int]=(1920, 1080), audio_enabled: bool=True, metadata: Optional[Dict[\n    str, Any]]=None):\n    self.codec = codec\n    self.bitrate = bitrate\n    self.resolution = resolution\n    self.audio_enabled = audio_enabled\n    self.metadata = metadata\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring correctly documents all parameter names and descriptions, but has an incorrect type for the 'codec' parameter. The docstring shows 'codec: List[str]' but the constructor signature shows 'codec: str'. All other parameter types and descriptions are accurate.",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Process video files with various transformations",
                "correct_class_arguments": [
                    {
                        "name": "codec",
                        "data_type": "str",
                        "description": "Video codec to use for encoding"
                    },
                    {
                        "name": "bitrate",
                        "data_type": "int",
                        "description": "Target bitrate in kbps. Defaults to 2000"
                    },
                    {
                        "name": "resolution",
                        "data_type": "Tuple[int, int]",
                        "description": "Output resolution as (width, height). Defaults to (1920, 1080)"
                    },
                    {
                        "name": "audio_enabled",
                        "data_type": "bool",
                        "description": "Whether to include audio track. Defaults to True"
                    },
                    {
                        "name": "metadata",
                        "data_type": "Optional[Dict[str, Any]]",
                        "description": "Custom metadata to embed in output. Defaults to None"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "EventScheduler",
            "lineno": 136,
            "end_lineno": 154,
            "col_offset": 0,
            "end_col_offset": 54,
            "source_code": "class EventScheduler:\n    \"\"\"Schedule and manage recurring events.\n\n    Args:\n        timezone: str\n            Timezone for event scheduling (e.g., 'UTC', 'America/New_York').\n        max_events: int\n            Maximum number of events to track simultaneously. Defaults to 1000.\n        persist_to_disk: bool\n            Whether to save events to disk for persistence. Defaults to False.\n        notification_buffer: timedelta\n            How far in advance to trigger notifications. Defaults to 15 minutes.\n    \"\"\"\n\n    def __init__(self, timezone: str, max_events: int=1000, persist_to_disk:\n        bool=False, notification_buffer: timedelta=timedelta(minutes=15)):\n        self.timezone = timezone\n        self.max_events = max_events\n        self.persist_to_disk = persist_to_disk\n        self.notification_buffer = notification_buffer\n",
            "docstring": "Schedule and manage recurring events.\n\nArgs:\n    timezone: str\n        Timezone for event scheduling (e.g., 'UTC', 'America/New_York').\n    max_events: int\n        Maximum number of events to track simultaneously. Defaults to 1000.\n    persist_to_disk: bool\n        Whether to save events to disk for persistence. Defaults to False.\n    notification_buffer: timedelta\n        How far in advance to trigger notifications. Defaults to 15 minutes.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 149,
                "end_lineno": 154,
                "col_offset": 4,
                "end_col_offset": 54,
                "source_code": "def __init__(self, timezone: str, max_events: int=1000, persist_to_disk:\n    bool=False, notification_buffer: timedelta=timedelta(minutes=15)):\n    self.timezone = timezone\n    self.max_events = max_events\n    self.persist_to_disk = persist_to_disk\n    self.notification_buffer = notification_buffer\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is mostly correct but has one type error. The parameter 'notification_buffer' is documented as 'timedelta' but should be 'timedelta' - actually looking more carefully, the constructor signature shows 'timedelta' type and the docstring also shows 'timedelta', which is correct. All parameter names are present, descriptions are clear and accurate with default values mentioned, making this a well-documented class.",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Schedule and manage recurring events",
                "correct_class_arguments": [
                    {
                        "name": "timezone",
                        "data_type": "str",
                        "description": "Timezone for event scheduling (e.g., 'UTC', 'America/New_York')."
                    },
                    {
                        "name": "max_events",
                        "data_type": "int",
                        "description": "Maximum number of events to track simultaneously. Defaults to 1000."
                    },
                    {
                        "name": "persist_to_disk",
                        "data_type": "bool",
                        "description": "Whether to save events to disk for persistence. Defaults to False."
                    },
                    {
                        "name": "notification_buffer",
                        "data_type": "timedelta",
                        "description": "How far in advance to trigger notifications. Defaults to 15 minutes."
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "SearchEngine",
            "lineno": 157,
            "end_lineno": 182,
            "col_offset": 0,
            "end_col_offset": 36,
            "source_code": "class SearchEngine:\n    \"\"\"Full-text search engine with indexing and ranking.\n\n    Args:\n        index_path: Path\n            Directory path where search index will be stored.\n        language: str\n            Language for text processing and stemming. Defaults to 'english'.\n        max_results: int\n            Maximum number of search results to return. Defaults to 50.\n        fuzzy_matching: bool\n            Whether to enable fuzzy string matching. Defaults to True.\n        boost_factors: Optional[Dict[str, float]]\n            Field boost factors for ranking. Defaults to None.\n        stop_words: Optional[Set[str]]\n            Custom stop words to filter out. Defaults to None.\n    \"\"\"\n\n    def __init__(self, index_path: Path, language: str='english',\n        max_results: int=50, fuzzy_matching: bool=True, boost_factors:\n        Optional[Dict[str, float]]=None, stop_words: Optional[Set[str]]=None):\n        self.index_path = index_path\n        self.language = language\n        self.max_results = max_results\n        self.fuzzy_matching = fuzzy_matching\n        self.boost_factors = boost_factors\n        self.stop_words = stop_words\n",
            "docstring": "Full-text search engine with indexing and ranking.\n\nArgs:\n    index_path: Path\n        Directory path where search index will be stored.\n    language: str\n        Language for text processing and stemming. Defaults to 'english'.\n    max_results: int\n        Maximum number of search results to return. Defaults to 50.\n    fuzzy_matching: bool\n        Whether to enable fuzzy string matching. Defaults to True.\n    boost_factors: Optional[Dict[str, float]]\n        Field boost factors for ranking. Defaults to None.\n    stop_words: Optional[Set[str]]\n        Custom stop words to filter out. Defaults to None.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 174,
                "end_lineno": 182,
                "col_offset": 4,
                "end_col_offset": 36,
                "source_code": "def __init__(self, index_path: Path, language: str='english', max_results:\n    int=50, fuzzy_matching: bool=True, boost_factors: Optional[Dict[str,\n    float]]=None, stop_words: Optional[Set[str]]=None):\n    self.index_path = index_path\n    self.language = language\n    self.max_results = max_results\n    self.fuzzy_matching = fuzzy_matching\n    self.boost_factors = boost_factors\n    self.stop_words = stop_words\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is already perfect. All constructor parameters are correctly documented with accurate names, types, and descriptions including default values. No corrections needed.",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Full-text search engine with indexing and ranking",
                "correct_class_arguments": [
                    {
                        "name": "index_path",
                        "data_type": "Path",
                        "description": "Directory path where search index will be stored"
                    },
                    {
                        "name": "language",
                        "data_type": "str",
                        "description": "Language for text processing and stemming. Defaults to 'english'"
                    },
                    {
                        "name": "max_results",
                        "data_type": "int",
                        "description": "Maximum number of search results to return. Defaults to 50"
                    },
                    {
                        "name": "fuzzy_matching",
                        "data_type": "bool",
                        "description": "Whether to enable fuzzy string matching. Defaults to True"
                    },
                    {
                        "name": "boost_factors",
                        "data_type": "Optional[Dict[str, float]]",
                        "description": "Field boost factors for ranking. Defaults to None"
                    },
                    {
                        "name": "stop_words",
                        "data_type": "Optional[Set[str]]",
                        "description": "Custom stop words to filter out. Defaults to None"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "MetricsCollector",
            "lineno": 185,
            "end_lineno": 210,
            "col_offset": 0,
            "end_col_offset": 36,
            "source_code": "class MetricsCollector:\n    \"\"\"Collect and aggregate application performance metrics.\n\n    Args:\n        collection_interval: float\n            Interval between metric collections in seconds. Defaults to 60.0.\n        storage_backend: str\n            Backend for metric storage ('memory', 'redis', 'influxdb'). Defaults to 'memory'.\n        retention_period: timedelta\n            How long to retain metrics data. Defaults to 24 hours.\n        enable_histograms: bool\n            Whether to collect histogram metrics. Defaults to True.\n        tags: Optional[Dict[str, str]]\n            Default tags to apply to all metrics. Defaults to None.\n        batch_size: int\n            Number of metrics to batch before writing. Defaults to 100.\n    \"\"\"\n\n    def __init__(self, collection_interval: float=60.0, storage_backend:\n        str='memory', retention_period: timedelta=timedelta(hours=24),\n        enable_histograms: bool=True, tags: Optional[Dict[str, str]]=None,\n        batch_size: int=100):\n        self.collection_interval = collection_interval\n        self.storage_backend = storage_backend\n        self.retention_period = retention_period\n        self.enable_histograms = enable_histograms\n        self.tags = tags\n        self.batch_size = batch_size\n",
            "docstring": "Collect and aggregate application performance metrics.\n\nArgs:\n    collection_interval: float\n        Interval between metric collections in seconds. Defaults to 60.0.\n    storage_backend: str\n        Backend for metric storage ('memory', 'redis', 'influxdb'). Defaults to 'memory'.\n    retention_period: timedelta\n        How long to retain metrics data. Defaults to 24 hours.\n    enable_histograms: bool\n        Whether to collect histogram metrics. Defaults to True.\n    tags: Optional[Dict[str, str]]\n        Default tags to apply to all metrics. Defaults to None.\n    batch_size: int\n        Number of metrics to batch before writing. Defaults to 100.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 202,
                "end_lineno": 210,
                "col_offset": 4,
                "end_col_offset": 36,
                "source_code": "def __init__(self, collection_interval: float=60.0, storage_backend: str=\n    'memory', retention_period: timedelta=timedelta(hours=24),\n    enable_histograms: bool=True, tags: Optional[Dict[str, str]]=None,\n    batch_size: int=100):\n    self.collection_interval = collection_interval\n    self.storage_backend = storage_backend\n    self.retention_period = retention_period\n    self.enable_histograms = enable_histograms\n    self.tags = tags\n    self.batch_size = batch_size\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is excellent and accurately documents all constructor parameters. All parameter names match the constructor signature exactly, all data types are correct including the complex Optional[Dict[str, str]] type, and all descriptions are clear and specific with proper default value documentation. No corrections needed.",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Collect and aggregate application performance metrics",
                "correct_class_arguments": [
                    {
                        "name": "collection_interval",
                        "data_type": "float",
                        "description": "Interval between metric collections in seconds. Defaults to 60.0."
                    },
                    {
                        "name": "storage_backend",
                        "data_type": "str",
                        "description": "Backend for metric storage ('memory', 'redis', 'influxdb'). Defaults to 'memory'."
                    },
                    {
                        "name": "retention_period",
                        "data_type": "timedelta",
                        "description": "How long to retain metrics data. Defaults to 24 hours."
                    },
                    {
                        "name": "enable_histograms",
                        "data_type": "bool",
                        "description": "Whether to collect histogram metrics. Defaults to True."
                    },
                    {
                        "name": "tags",
                        "data_type": "Optional[Dict[str, str]]",
                        "description": "Default tags to apply to all metrics. Defaults to None."
                    },
                    {
                        "name": "batch_size",
                        "data_type": "int",
                        "description": "Number of metrics to batch before writing. Defaults to 100."
                    }
                ]
            }
        }
    }
]
