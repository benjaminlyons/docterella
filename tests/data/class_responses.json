[
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "MessageQueue",
            "lineno": 12,
            "end_lineno": 25,
            "col_offset": 0,
            "end_col_offset": 38,
            "source_code": "class MessageQueue:\n    \"\"\"Handle message queuing and processing.\n\n    Args:\n        queue_name: str\n            Name of the message queue.\n        max_size: int\n            Maximum number of messages in queue.\n    \"\"\"\n\n    def __init__(self, queue_name: str, max_size: int, retry_attempts: int,\n        persistence: bool=True):\n        self.queue_name = queue_name\n        self.max_size = max_size\n        self.retry_attempts = retry_attempts\n        self.persistence = persistence\n",
            "docstring": "Handle message queuing and processing.\n\nArgs:\n    queue_name: str\n        Name of the message queue.\n    max_size: int\n        Maximum number of messages in queue.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 21,
                "end_lineno": 25,
                "col_offset": 4,
                "end_col_offset": 38,
                "source_code": "def __init__(self, queue_name: str, max_size: int, retry_attempts: int,\n    persistence: bool=True):\n    self.queue_name = queue_name\n    self.max_size = max_size\n    self.retry_attempts = retry_attempts\n    self.persistence = persistence\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is missing two constructor parameters: 'retry_attempts' (int) and 'persistence' (bool with default True). The existing documented parameters have correct types and descriptions, but the missing parameters need to be added to make the documentation complete.",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Handle message queuing and processing",
                "correct_class_arguments": [
                    {
                        "name": "queue_name",
                        "data_type": "str",
                        "description": "Name of the message queue."
                    },
                    {
                        "name": "max_size",
                        "data_type": "int",
                        "description": "Maximum number of messages in queue."
                    },
                    {
                        "name": "retry_attempts",
                        "data_type": "int",
                        "description": "Number of retry attempts for failed message processing."
                    },
                    {
                        "name": "persistence",
                        "data_type": "bool",
                        "description": "Whether to enable message persistence. Defaults to True."
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "ImageResizer",
            "lineno": 28,
            "end_lineno": 41,
            "col_offset": 0,
            "end_col_offset": 30,
            "source_code": "class ImageResizer:\n    \"\"\"Resize and optimize images for web usage.\n\n    Args:\n        input_path: int\n            Path to input image file.\n        quality: str\n            Image compression quality setting.\n        preserve_metadata: bool\n            Whether to keep EXIF data in output.\n    \"\"\"\n\n    def __init__(self, input_path: str, quality: int=85):\n        self.input_path = input_path\n        self.quality = quality\n",
            "docstring": "Resize and optimize images for web usage.\n\nArgs:\n    input_path: int\n        Path to input image file.\n    quality: str\n        Image compression quality setting.\n    preserve_metadata: bool\n        Whether to keep EXIF data in output.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 39,
                "end_lineno": 41,
                "col_offset": 4,
                "end_col_offset": 30,
                "source_code": "def __init__(self, input_path: str, quality: int=85):\n    self.input_path = input_path\n    self.quality = quality\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring has multiple issues: (1) Missing parameter - 'preserve_metadata' is documented but doesn't exist in the constructor, (2) Wrong type - 'input_path' is documented as 'int' but should be 'str', (3) Wrong type - 'quality' is documented as 'str' but should be 'int', (4) Missing default value - the docstring doesn't mention that 'quality' defaults to 85. Fixed by removing the non-existent parameter, correcting the types, and adding default value information.",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": false,
            "corrected_class_docstring": {
                "correct_class_description": "Resize and optimize images for web usage",
                "correct_class_arguments": [
                    {
                        "name": "input_path",
                        "data_type": "str",
                        "description": "Path to input image file"
                    },
                    {
                        "name": "quality",
                        "data_type": "int",
                        "description": "Image compression quality setting. Defaults to 85"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "PasswordValidator",
            "lineno": 44,
            "end_lineno": 50,
            "col_offset": 0,
            "end_col_offset": 42,
            "source_code": "class PasswordValidator:\n\n    def __init__(self, min_length: int=8, require_uppercase: bool=True,\n        require_numbers: bool=True, special_chars: Optional[str]=None):\n        self.min_length = min_length\n        self.require_uppercase = require_uppercase\n        self.require_numbers = require_numbers\n        self.special_chars = special_chars\n",
            "docstring": null,
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 45,
                "end_lineno": 50,
                "col_offset": 4,
                "end_col_offset": 42,
                "source_code": "def __init__(self, min_length: int=8, require_uppercase: bool=True,\n    require_numbers: bool=True, special_chars: Optional[str]=None):\n    self.min_length = min_length\n    self.require_uppercase = require_uppercase\n    self.require_numbers = require_numbers\n    self.special_chars = special_chars\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The class has no docstring at all, so all validation flags are false. The constructor has 4 parameters with various types and default values that need to be documented. Created a complete docstring following Google format with proper parameter documentation including types and default values.",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": false,
            "corrected_class_docstring": {
                "correct_class_description": "Validate password strength based on configurable criteria",
                "correct_class_arguments": [
                    {
                        "name": "min_length",
                        "data_type": "int",
                        "description": "Minimum required password length. Defaults to 8."
                    },
                    {
                        "name": "require_uppercase",
                        "data_type": "bool",
                        "description": "Whether to require at least one uppercase letter. Defaults to True."
                    },
                    {
                        "name": "require_numbers",
                        "data_type": "bool",
                        "description": "Whether to require at least one numeric digit. Defaults to True."
                    },
                    {
                        "name": "special_chars",
                        "data_type": "Optional[str]",
                        "description": "String of special characters to require in password. Defaults to None."
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "NotificationService",
            "lineno": 53,
            "end_lineno": 70,
            "col_offset": 0,
            "end_col_offset": 38,
            "source_code": "class NotificationService:\n    \"\"\"Send notifications via multiple channels.\n\n    Args:\n        email_enabled: bool\n            Whether email notifications are enabled.\n        sms_enabled: bool\n            Whether SMS notifications are enabled.\n        webhook_url: str\n            URL for webhook notifications.\n        rate_limit: int\n            Maximum notifications per minute.\n        templates: Dict[str, str]\n            Notification template mappings.\n    \"\"\"\n\n    def __init__(self, email_enabled: bool, sms_enabled: bool=False):\n        self.email_enabled = email_enabled\n        self.sms_enabled = sms_enabled\n",
            "docstring": "Send notifications via multiple channels.\n\nArgs:\n    email_enabled: bool\n        Whether email notifications are enabled.\n    sms_enabled: bool\n        Whether SMS notifications are enabled.\n    webhook_url: str\n        URL for webhook notifications.\n    rate_limit: int\n        Maximum notifications per minute.\n    templates: Dict[str, str]\n        Notification template mappings.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 68,
                "end_lineno": 70,
                "col_offset": 4,
                "end_col_offset": 38,
                "source_code": "def __init__(self, email_enabled: bool, sms_enabled: bool=False):\n    self.email_enabled = email_enabled\n    self.sms_enabled = sms_enabled\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring documents 5 parameters (email_enabled, sms_enabled, webhook_url, rate_limit, templates) but the constructor only has 2 parameters (email_enabled, sms_enabled). The documented types for the existing parameters are correct, but the description for sms_enabled is missing the default value information. The extra parameters webhook_url, rate_limit, and templates need to be removed from the docstring.",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": false,
            "corrected_class_docstring": {
                "correct_class_description": "Send notifications via multiple channels",
                "correct_class_arguments": [
                    {
                        "name": "email_enabled",
                        "data_type": "bool",
                        "description": "Whether email notifications are enabled."
                    },
                    {
                        "name": "sms_enabled",
                        "data_type": "bool",
                        "description": "Whether SMS notifications are enabled. Defaults to False."
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "HttpClient",
            "lineno": 73,
            "end_lineno": 91,
            "col_offset": 0,
            "end_col_offset": 36,
            "source_code": "class HttpClient:\n    \"\"\"HTTP client for making REST API requests.\n\n    Args:\n        base_url: str\n            The URL.\n        timeout: int\n            The timeout.\n        retries: int\n            The retries.\n        user_agent: str\n            The user agent.\n    \"\"\"\n\n    def __init__(self, base_url: str, timeout: float=30.0, retries: int=3,\n        user_agent: str='HttpClient/1.0'):\n        self.base_url = base_url\n        self.timeout = timeout\n        self.retries = retries\n        self.user_agent = user_agent\n",
            "docstring": "HTTP client for making REST API requests.\n\nArgs:\n    base_url: str\n        The URL.\n    timeout: int\n        The timeout.\n    retries: int\n        The retries.\n    user_agent: str\n        The user agent.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 86,
                "end_lineno": 91,
                "col_offset": 4,
                "end_col_offset": 36,
                "source_code": "def __init__(self, base_url: str, timeout: float=30.0, retries: int=3,\n    user_agent: str='HttpClient/1.0'):\n    self.base_url = base_url\n    self.timeout = timeout\n    self.retries = retries\n    self.user_agent = user_agent\n"
            }
        },
        "assessment": {
            "summary_of_findings": "All constructor parameters are documented but there are two main issues: (1) the timeout parameter type is documented as 'int' but should be 'float' according to the constructor signature, and (2) all parameter descriptions are too vague (e.g., 'The URL', 'The timeout') and don't mention default values for optional parameters. Fixed by providing clear, specific descriptions and correcting the timeout type to 'float'.",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": false,
            "corrected_class_docstring": {
                "correct_class_description": "HTTP client for making REST API requests",
                "correct_class_arguments": [
                    {
                        "name": "base_url",
                        "data_type": "str",
                        "description": "Base URL for the API endpoint"
                    },
                    {
                        "name": "timeout",
                        "data_type": "float",
                        "description": "Request timeout in seconds. Defaults to 30.0"
                    },
                    {
                        "name": "retries",
                        "data_type": "int",
                        "description": "Maximum number of retry attempts for failed requests. Defaults to 3"
                    },
                    {
                        "name": "user_agent",
                        "data_type": "str",
                        "description": "User agent string for HTTP requests. Defaults to 'HttpClient/1.0'"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "BackupManager",
            "lineno": 94,
            "end_lineno": 110,
            "col_offset": 0,
            "end_col_offset": 46,
            "source_code": "class BackupManager:\n    \"\"\"Manage automated backups of files and databases.\n\n    Args:\n        backup_directory: str\n            Directory where backups will be stored.\n        retention_days: int\n            Number of days to keep backups.\n        compression_enabled: bool\n            Whether to compress backup files.\n    \"\"\"\n\n    def __init__(self, backup_directory: str, retention_days: int=30,\n        compression_enabled: bool=True, max_backup_size: int=1073741824):\n        self.backup_directory = backup_directory\n        self.retention_days = retention_days\n        self.compression_enabled = compression_enabled\n        self.max_backup_size = max_backup_size\n",
            "docstring": "Manage automated backups of files and databases.\n\nArgs:\n    backup_directory: str\n        Directory where backups will be stored.\n    retention_days: int\n        Number of days to keep backups.\n    compression_enabled: bool\n        Whether to compress backup files.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 105,
                "end_lineno": 110,
                "col_offset": 4,
                "end_col_offset": 46,
                "source_code": "def __init__(self, backup_directory: str, retention_days: int=30,\n    compression_enabled: bool=True, max_backup_size: int=1073741824):\n    self.backup_directory = backup_directory\n    self.retention_days = retention_days\n    self.compression_enabled = compression_enabled\n    self.max_backup_size = max_backup_size\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is missing the 'max_backup_size' parameter which exists in the constructor. Additionally, the descriptions for optional parameters (retention_days and compression_enabled) don't mention their default values, which should be included for clarity.",
            "parameter_names_are_correct": false,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": false,
            "corrected_class_docstring": {
                "correct_class_description": "Manage automated backups of files and databases",
                "correct_class_arguments": [
                    {
                        "name": "backup_directory",
                        "data_type": "str",
                        "description": "Directory where backups will be stored."
                    },
                    {
                        "name": "retention_days",
                        "data_type": "int",
                        "description": "Number of days to keep backups. Defaults to 30."
                    },
                    {
                        "name": "compression_enabled",
                        "data_type": "bool",
                        "description": "Whether to compress backup files. Defaults to True."
                    },
                    {
                        "name": "max_backup_size",
                        "data_type": "int",
                        "description": "Maximum size limit for backup files in bytes. Defaults to 1073741824."
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "VideoProcessor",
            "lineno": 112,
            "end_lineno": 133,
            "col_offset": 0,
            "end_col_offset": 32,
            "source_code": "class VideoProcessor:\n    \"\"\"Process video files with various transformations.\n\n    Args:\n        codec: List[str]\n            Video codec to use for encoding.\n        bitrate: int\n            Target bitrate in kbps. Defaults to 2000.\n        resolution: Tuple[int, int]\n            Output resolution as (width, height). Defaults to (1920, 1080).\n        audio_enabled: bool\n            Whether to include audio track. Defaults to True.\n        metadata: Optional[Dict[str, Any]]\n            Custom metadata to embed in output. Defaults to None.\n    \"\"\"\n\n    def __init__(self, codec: str, bitrate: int=2000, resolution: Tuple[int,\n        int]=(1920, 1080), audio_enabled: bool=True, metadata: Optional[\n        Dict[str, Any]]=None):\n        self.codec = codec\n        self.bitrate = bitrate\n        self.resolution = resolution\n        self.audio_enabled = audio_enabled\n        self.metadata = metadata\n",
            "docstring": "Process video files with various transformations.\n\nArgs:\n    codec: List[str]\n        Video codec to use for encoding.\n    bitrate: int\n        Target bitrate in kbps. Defaults to 2000.\n    resolution: Tuple[int, int]\n        Output resolution as (width, height). Defaults to (1920, 1080).\n    audio_enabled: bool\n        Whether to include audio track. Defaults to True.\n    metadata: Optional[Dict[str, Any]]\n        Custom metadata to embed in output. Defaults to None.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 127,
                "end_lineno": 133,
                "col_offset": 4,
                "end_col_offset": 32,
                "source_code": "def __init__(self, codec: str, bitrate: int=2000, resolution: Tuple[int,\n    int]=(1920, 1080), audio_enabled: bool=True, metadata: Optional[Dict[\n    str, Any]]=None):\n    self.codec = codec\n    self.bitrate = bitrate\n    self.resolution = resolution\n    self.audio_enabled = audio_enabled\n    self.metadata = metadata\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring has all correct parameter names and good descriptions, but the type for 'codec' is incorrect. The docstring shows 'List[str]' but the constructor signature shows 'str'. Fixed the type documentation to match the actual constructor parameter type.",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Process video files with various transformations",
                "correct_class_arguments": [
                    {
                        "name": "codec",
                        "data_type": "str",
                        "description": "Video codec to use for encoding"
                    },
                    {
                        "name": "bitrate",
                        "data_type": "int",
                        "description": "Target bitrate in kbps. Defaults to 2000"
                    },
                    {
                        "name": "resolution",
                        "data_type": "Tuple[int, int]",
                        "description": "Output resolution as (width, height). Defaults to (1920, 1080)"
                    },
                    {
                        "name": "audio_enabled",
                        "data_type": "bool",
                        "description": "Whether to include audio track. Defaults to True"
                    },
                    {
                        "name": "metadata",
                        "data_type": "Optional[Dict[str, Any]]",
                        "description": "Custom metadata to embed in output. Defaults to None"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "EventScheduler",
            "lineno": 136,
            "end_lineno": 154,
            "col_offset": 0,
            "end_col_offset": 54,
            "source_code": "class EventScheduler:\n    \"\"\"Schedule and manage recurring events.\n\n    Args:\n        timezone: str\n            Timezone for event scheduling (e.g., 'UTC', 'America/New_York').\n        max_events: int\n            Maximum number of events to track simultaneously. Defaults to 1000.\n        persist_to_disk: bool\n            Whether to save events to disk for persistence. Defaults to False.\n        notification_buffer: timedelta\n            How far in advance to trigger notifications. Defaults to 15 minutes.\n    \"\"\"\n\n    def __init__(self, timezone: str, max_events: int=1000, persist_to_disk:\n        bool=False, notification_buffer: timedelta=timedelta(minutes=15)):\n        self.timezone = timezone\n        self.max_events = max_events\n        self.persist_to_disk = persist_to_disk\n        self.notification_buffer = notification_buffer\n",
            "docstring": "Schedule and manage recurring events.\n\nArgs:\n    timezone: str\n        Timezone for event scheduling (e.g., 'UTC', 'America/New_York').\n    max_events: int\n        Maximum number of events to track simultaneously. Defaults to 1000.\n    persist_to_disk: bool\n        Whether to save events to disk for persistence. Defaults to False.\n    notification_buffer: timedelta\n        How far in advance to trigger notifications. Defaults to 15 minutes.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 149,
                "end_lineno": 154,
                "col_offset": 4,
                "end_col_offset": 54,
                "source_code": "def __init__(self, timezone: str, max_events: int=1000, persist_to_disk:\n    bool=False, notification_buffer: timedelta=timedelta(minutes=15)):\n    self.timezone = timezone\n    self.max_events = max_events\n    self.persist_to_disk = persist_to_disk\n    self.notification_buffer = notification_buffer\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is mostly correct with all parameter names present and descriptions accurate with default values mentioned. However, the type for notification_buffer is incorrect - it should be 'timedelta' not 'timedelta' (though both appear identical, the constructor signature shows it should be the timedelta type). All parameter names match the constructor and descriptions are clear and helpful.",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": false,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Schedule and manage recurring events",
                "correct_class_arguments": [
                    {
                        "name": "timezone",
                        "data_type": "str",
                        "description": "Timezone for event scheduling (e.g., 'UTC', 'America/New_York')."
                    },
                    {
                        "name": "max_events",
                        "data_type": "int",
                        "description": "Maximum number of events to track simultaneously. Defaults to 1000."
                    },
                    {
                        "name": "persist_to_disk",
                        "data_type": "bool",
                        "description": "Whether to save events to disk for persistence. Defaults to False."
                    },
                    {
                        "name": "notification_buffer",
                        "data_type": "timedelta",
                        "description": "How far in advance to trigger notifications. Defaults to 15 minutes."
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "SearchEngine",
            "lineno": 157,
            "end_lineno": 182,
            "col_offset": 0,
            "end_col_offset": 36,
            "source_code": "class SearchEngine:\n    \"\"\"Full-text search engine with indexing and ranking.\n\n    Args:\n        index_path: Path\n            Directory path where search index will be stored.\n        language: str\n            Language for text processing and stemming. Defaults to 'english'.\n        max_results: int\n            Maximum number of search results to return. Defaults to 50.\n        fuzzy_matching: bool\n            Whether to enable fuzzy string matching. Defaults to True.\n        boost_factors: Optional[Dict[str, float]]\n            Field boost factors for ranking. Defaults to None.\n        stop_words: Optional[Set[str]]\n            Custom stop words to filter out. Defaults to None.\n    \"\"\"\n\n    def __init__(self, index_path: Path, language: str='english',\n        max_results: int=50, fuzzy_matching: bool=True, boost_factors:\n        Optional[Dict[str, float]]=None, stop_words: Optional[Set[str]]=None):\n        self.index_path = index_path\n        self.language = language\n        self.max_results = max_results\n        self.fuzzy_matching = fuzzy_matching\n        self.boost_factors = boost_factors\n        self.stop_words = stop_words\n",
            "docstring": "Full-text search engine with indexing and ranking.\n\nArgs:\n    index_path: Path\n        Directory path where search index will be stored.\n    language: str\n        Language for text processing and stemming. Defaults to 'english'.\n    max_results: int\n        Maximum number of search results to return. Defaults to 50.\n    fuzzy_matching: bool\n        Whether to enable fuzzy string matching. Defaults to True.\n    boost_factors: Optional[Dict[str, float]]\n        Field boost factors for ranking. Defaults to None.\n    stop_words: Optional[Set[str]]\n        Custom stop words to filter out. Defaults to None.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 174,
                "end_lineno": 182,
                "col_offset": 4,
                "end_col_offset": 36,
                "source_code": "def __init__(self, index_path: Path, language: str='english', max_results:\n    int=50, fuzzy_matching: bool=True, boost_factors: Optional[Dict[str,\n    float]]=None, stop_words: Optional[Set[str]]=None):\n    self.index_path = index_path\n    self.language = language\n    self.max_results = max_results\n    self.fuzzy_matching = fuzzy_matching\n    self.boost_factors = boost_factors\n    self.stop_words = stop_words\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is excellent and accurately documents all constructor parameters. All parameter names match exactly, types are correct including complex types like Optional[Dict[str, float]], and descriptions are clear with default values properly mentioned. The only minor adjustment made was to the class description to start with a verb as per best practices.",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Provide full-text search engine with indexing and ranking",
                "correct_class_arguments": [
                    {
                        "name": "index_path",
                        "data_type": "Path",
                        "description": "Directory path where search index will be stored"
                    },
                    {
                        "name": "language",
                        "data_type": "str",
                        "description": "Language for text processing and stemming. Defaults to 'english'"
                    },
                    {
                        "name": "max_results",
                        "data_type": "int",
                        "description": "Maximum number of search results to return. Defaults to 50"
                    },
                    {
                        "name": "fuzzy_matching",
                        "data_type": "bool",
                        "description": "Whether to enable fuzzy string matching. Defaults to True"
                    },
                    {
                        "name": "boost_factors",
                        "data_type": "Optional[Dict[str, float]]",
                        "description": "Field boost factors for ranking. Defaults to None"
                    },
                    {
                        "name": "stop_words",
                        "data_type": "Optional[Set[str]]",
                        "description": "Custom stop words to filter out. Defaults to None"
                    }
                ]
            }
        }
    },
    {
        "metadata": {
            "source_path": "tests/data/class.py",
            "name": "MetricsCollector",
            "lineno": 185,
            "end_lineno": 210,
            "col_offset": 0,
            "end_col_offset": 36,
            "source_code": "class MetricsCollector:\n    \"\"\"Collect and aggregate application performance metrics.\n\n    Args:\n        collection_interval: float\n            Interval between metric collections in seconds. Defaults to 60.0.\n        storage_backend: str\n            Backend for metric storage ('memory', 'redis', 'influxdb'). Defaults to 'memory'.\n        retention_period: timedelta\n            How long to retain metrics data. Defaults to 24 hours.\n        enable_histograms: bool\n            Whether to collect histogram metrics. Defaults to True.\n        tags: Optional[Dict[str, str]]\n            Default tags to apply to all metrics. Defaults to None.\n        batch_size: int\n            Number of metrics to batch before writing. Defaults to 100.\n    \"\"\"\n\n    def __init__(self, collection_interval: float=60.0, storage_backend:\n        str='memory', retention_period: timedelta=timedelta(hours=24),\n        enable_histograms: bool=True, tags: Optional[Dict[str, str]]=None,\n        batch_size: int=100):\n        self.collection_interval = collection_interval\n        self.storage_backend = storage_backend\n        self.retention_period = retention_period\n        self.enable_histograms = enable_histograms\n        self.tags = tags\n        self.batch_size = batch_size\n",
            "docstring": "Collect and aggregate application performance metrics.\n\nArgs:\n    collection_interval: float\n        Interval between metric collections in seconds. Defaults to 60.0.\n    storage_backend: str\n        Backend for metric storage ('memory', 'redis', 'influxdb'). Defaults to 'memory'.\n    retention_period: timedelta\n        How long to retain metrics data. Defaults to 24 hours.\n    enable_histograms: bool\n        Whether to collect histogram metrics. Defaults to True.\n    tags: Optional[Dict[str, str]]\n        Default tags to apply to all metrics. Defaults to None.\n    batch_size: int\n        Number of metrics to batch before writing. Defaults to 100.",
            "constructor": {
                "source_path": null,
                "name": "__init__",
                "lineno": 202,
                "end_lineno": 210,
                "col_offset": 4,
                "end_col_offset": 36,
                "source_code": "def __init__(self, collection_interval: float=60.0, storage_backend: str=\n    'memory', retention_period: timedelta=timedelta(hours=24),\n    enable_histograms: bool=True, tags: Optional[Dict[str, str]]=None,\n    batch_size: int=100):\n    self.collection_interval = collection_interval\n    self.storage_backend = storage_backend\n    self.retention_period = retention_period\n    self.enable_histograms = enable_histograms\n    self.tags = tags\n    self.batch_size = batch_size\n"
            }
        },
        "assessment": {
            "summary_of_findings": "The docstring is excellent and correctly documents all constructor parameters. All parameter names match exactly with the constructor signature, all types are accurate (including complex types like Optional[Dict[str, str]] and timedelta), and all descriptions are clear and specific with default values properly mentioned. No corrections needed.",
            "parameter_names_are_correct": true,
            "parameter_types_are_correct": true,
            "parameter_descriptions_are_correct": true,
            "corrected_class_docstring": {
                "correct_class_description": "Collect and aggregate application performance metrics",
                "correct_class_arguments": [
                    {
                        "name": "collection_interval",
                        "data_type": "float",
                        "description": "Interval between metric collections in seconds. Defaults to 60.0."
                    },
                    {
                        "name": "storage_backend",
                        "data_type": "str",
                        "description": "Backend for metric storage ('memory', 'redis', 'influxdb'). Defaults to 'memory'."
                    },
                    {
                        "name": "retention_period",
                        "data_type": "timedelta",
                        "description": "How long to retain metrics data. Defaults to 24 hours."
                    },
                    {
                        "name": "enable_histograms",
                        "data_type": "bool",
                        "description": "Whether to collect histogram metrics. Defaults to True."
                    },
                    {
                        "name": "tags",
                        "data_type": "Optional[Dict[str, str]]",
                        "description": "Default tags to apply to all metrics. Defaults to None."
                    },
                    {
                        "name": "batch_size",
                        "data_type": "int",
                        "description": "Number of metrics to batch before writing. Defaults to 100."
                    }
                ]
            }
        }
    }
]
